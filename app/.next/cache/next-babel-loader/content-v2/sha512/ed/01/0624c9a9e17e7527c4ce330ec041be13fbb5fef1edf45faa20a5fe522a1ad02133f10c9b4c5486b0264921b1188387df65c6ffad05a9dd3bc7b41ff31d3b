{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Float32BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3 } from '../../../build/three.module.js';\nvar BufferGeometryUtils = {\n  computeTangents: function computeTangents(geometry) {\n    geometry.computeTangents();\n    console.warn('THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.');\n  },\n\n  /**\n   * @param  {Array<BufferGeometry>} geometries\n   * @param  {Boolean} useGroups\n   * @return {BufferGeometry}\n   */\n  mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {\n    var isIndexed = geometries[0].index !== null;\n    var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    var attributes = {};\n    var morphAttributes = {};\n    var morphTargetsRelative = geometries[0].morphTargetsRelative;\n    var mergedGeometry = new BufferGeometry();\n    var offset = 0;\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var geometry = geometries[i];\n      var attributesCount = 0; // ensure that all geometries are indexed, or none\n\n      if (isIndexed !== (geometry.index !== null)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n        return null;\n      } // gather attributes, exit early if they're different\n\n\n      for (var name in geometry.attributes) {\n        if (!attributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n          return null;\n        }\n\n        if (attributes[name] === undefined) attributes[name] = [];\n        attributes[name].push(geometry.attributes[name]);\n        attributesCount++;\n      } // ensure geometries have the same number of attributes\n\n\n      if (attributesCount !== attributesUsed.size) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n        return null;\n      } // gather morph attributes, exit early if they're different\n\n\n      if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n        return null;\n      }\n\n      for (var name in geometry.morphAttributes) {\n        if (!morphAttributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n          return null;\n        }\n\n        if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n        morphAttributes[name].push(geometry.morphAttributes[name]);\n      } // gather .userData\n\n\n      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n      mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n      if (useGroups) {\n        var count;\n\n        if (isIndexed) {\n          count = geometry.index.count;\n        } else if (geometry.attributes.position !== undefined) {\n          count = geometry.attributes.position.count;\n        } else {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n          return null;\n        }\n\n        mergedGeometry.addGroup(offset, count, i);\n        offset += count;\n      }\n    } // merge indices\n\n\n    if (isIndexed) {\n      var indexOffset = 0;\n      var mergedIndex = [];\n\n      for (var i = 0; i < geometries.length; ++i) {\n        var index = geometries[i].index;\n\n        for (var j = 0; j < index.count; ++j) {\n          mergedIndex.push(index.getX(j) + indexOffset);\n        }\n\n        indexOffset += geometries[i].attributes.position.count;\n      }\n\n      mergedGeometry.setIndex(mergedIndex);\n    } // merge attributes\n\n\n    for (var name in attributes) {\n      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n\n      if (!mergedAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n        return null;\n      }\n\n      mergedGeometry.setAttribute(name, mergedAttribute);\n    } // merge morph attributes\n\n\n    for (var name in morphAttributes) {\n      var numMorphTargets = morphAttributes[name][0].length;\n      if (numMorphTargets === 0) break;\n      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n      mergedGeometry.morphAttributes[name] = [];\n\n      for (var i = 0; i < numMorphTargets; ++i) {\n        var morphAttributesToMerge = [];\n\n        for (var j = 0; j < morphAttributes[name].length; ++j) {\n          morphAttributesToMerge.push(morphAttributes[name][j][i]);\n        }\n\n        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n\n        if (!mergedMorphAttribute) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n          return null;\n        }\n\n        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n      }\n    }\n\n    return mergedGeometry;\n  },\n\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {BufferAttribute}\n   */\n  mergeBufferAttributes: function mergeBufferAttributes(attributes) {\n    var TypedArray;\n    var itemSize;\n    var normalized;\n    var arrayLength = 0;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      var attribute = attributes[i];\n\n      if (attribute.isInterleavedBufferAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n        return null;\n      }\n\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n        return null;\n      }\n\n      if (itemSize === undefined) itemSize = attribute.itemSize;\n\n      if (itemSize !== attribute.itemSize) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n        return null;\n      }\n\n      if (normalized === undefined) normalized = attribute.normalized;\n\n      if (normalized !== attribute.normalized) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n        return null;\n      }\n\n      arrayLength += attribute.array.length;\n    }\n\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      array.set(attributes[i].array, offset);\n      offset += attributes[i].array.length;\n    }\n\n    return new BufferAttribute(array, itemSize, normalized);\n  },\n\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {Array<InterleavedBufferAttribute>}\n   */\n  interleaveAttributes: function interleaveAttributes(attributes) {\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    var TypedArray;\n    var arrayLength = 0;\n    var stride = 0; // calculate the the length and type of the interleavedBuffer\n\n    for (var i = 0, l = attributes.length; i < l; ++i) {\n      var attribute = attributes[i];\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('AttributeBuffers of different types cannot be interleaved');\n        return null;\n      }\n\n      arrayLength += attribute.array.length;\n      stride += attribute.itemSize;\n    } // Create the set of buffer attributes\n\n\n    var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n    var offset = 0;\n    var res = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW'];\n    var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n    for (var j = 0, l = attributes.length; j < l; j++) {\n      var attribute = attributes[j];\n      var itemSize = attribute.itemSize;\n      var count = attribute.count;\n      var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n      res.push(iba);\n      offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n      // at the appropriate offset\n\n      for (var c = 0; c < count; c++) {\n        for (var k = 0; k < itemSize; k++) {\n          iba[setters[k]](c, attribute[getters[k]](c));\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * @param {Array<BufferGeometry>} geometry\n   * @return {number}\n   */\n  estimateBytesUsed: function estimateBytesUsed(geometry) {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    var mem = 0;\n\n    for (var name in geometry.attributes) {\n      var attr = geometry.getAttribute(name);\n      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n\n    var indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n  },\n\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {BufferGeometry>}\n   */\n  mergeVertices: function mergeVertices(geometry) {\n    var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute('position');\n    var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n    var nextIndex = 0; // attributes and new attribute arrays\n\n    var attributeNames = Object.keys(geometry.attributes);\n    var attrArrays = {};\n    var morphAttrsArrays = {};\n    var newIndices = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      attrArrays[name] = [];\n      var morphAttr = geometry.morphAttributes[name];\n\n      if (morphAttr) {\n        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(function () {\n          return [];\n        });\n      }\n    } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n    var decimalShift = Math.log10(1 / tolerance);\n    var shiftMultiplier = Math.pow(10, decimalShift);\n\n    for (var i = 0; i < vertexCount; i++) {\n      var index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n      var hash = '';\n\n      for (var j = 0, l = attributeNames.length; j < l; j++) {\n        var name = attributeNames[j];\n        var attribute = geometry.getAttribute(name);\n        var itemSize = attribute.itemSize;\n\n        for (var k = 0; k < itemSize; k++) {\n          // double tilde truncates the decimal value\n          hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n        }\n      } // Add another reference to the vertex if it's already\n      // used by another index\n\n\n      if (hash in hashToIndex) {\n        newIndices.push(hashToIndex[hash]);\n      } else {\n        // copy data to the new index in the attribute arrays\n        for (var j = 0, l = attributeNames.length; j < l; j++) {\n          var name = attributeNames[j];\n          var attribute = geometry.getAttribute(name);\n          var morphAttr = geometry.morphAttributes[name];\n          var itemSize = attribute.itemSize;\n          var newarray = attrArrays[name];\n          var newMorphArrays = morphAttrsArrays[name];\n\n          for (var k = 0; k < itemSize; k++) {\n            var getterFunc = getters[k];\n            newarray.push(attribute[getterFunc](index));\n\n            if (morphAttr) {\n              for (var m = 0, ml = morphAttr.length; m < ml; m++) {\n                newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n              }\n            }\n          }\n        }\n\n        hashToIndex[hash] = nextIndex;\n        newIndices.push(nextIndex);\n        nextIndex++;\n      }\n    } // Generate typed arrays from new attribute arrays and update\n    // the attributeBuffers\n\n\n    var result = geometry.clone();\n\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      var oldAttribute = geometry.getAttribute(name);\n      var buffer = new oldAttribute.array.constructor(attrArrays[name]);\n      var attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n      result.setAttribute(name, attribute); // Update the attribute arrays\n\n      if (name in morphAttrsArrays) {\n        for (var j = 0; j < morphAttrsArrays[name].length; j++) {\n          var oldMorphAttribute = geometry.morphAttributes[name][j];\n          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n          var morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n          result.morphAttributes[name][j] = morphAttribute;\n        }\n      }\n    } // indices\n\n\n    result.setIndex(newIndices);\n    return result;\n  },\n\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} drawMode\n   * @return {BufferGeometry>}\n   */\n  toTrianglesDrawMode: function toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === TrianglesDrawMode) {\n      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n      return geometry;\n    }\n\n    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n      var index = geometry.getIndex(); // generate index if not present\n\n      if (index === null) {\n        var indices = [];\n        var position = geometry.getAttribute('position');\n\n        if (position !== undefined) {\n          for (var i = 0; i < position.count; i++) {\n            indices.push(i);\n          }\n\n          geometry.setIndex(indices);\n          index = geometry.getIndex();\n        } else {\n          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n          return geometry;\n        }\n      } //\n\n\n      var numberOfTriangles = index.count - 2;\n      var newIndices = [];\n\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n        for (var i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (var i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n\n      if (newIndices.length / 3 !== numberOfTriangles) {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n      } // build final geometry\n\n\n      var newGeometry = geometry.clone();\n      newGeometry.setIndex(newIndices);\n      newGeometry.clearGroups();\n      return newGeometry;\n    } else {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n      return geometry;\n    }\n  },\n\n  /**\n   * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n   * Helpful for Raytracing or Decals.\n   * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n   * @return {Object} An Object with original position/normal attributes and morphed ones.\n   */\n  computeMorphedAttributes: function computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n      console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n      return null;\n    }\n\n    var _vA = new Vector3();\n\n    var _vB = new Vector3();\n\n    var _vC = new Vector3();\n\n    var _tempA = new Vector3();\n\n    var _tempB = new Vector3();\n\n    var _tempC = new Vector3();\n\n    var _morphA = new Vector3();\n\n    var _morphB = new Vector3();\n\n    var _morphC = new Vector3();\n\n    function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n      _vA.fromBufferAttribute(attribute, a);\n\n      _vB.fromBufferAttribute(attribute, b);\n\n      _vC.fromBufferAttribute(attribute, c);\n\n      var morphInfluences = object.morphTargetInfluences;\n\n      if (material.morphTargets && morphAttribute && morphInfluences) {\n        _morphA.set(0, 0, 0);\n\n        _morphB.set(0, 0, 0);\n\n        _morphC.set(0, 0, 0);\n\n        for (var i = 0, il = morphAttribute.length; i < il; i++) {\n          var influence = morphInfluences[i];\n          var morphAttribute = morphAttribute[i];\n          if (influence === 0) continue;\n\n          _tempA.fromBufferAttribute(morphAttribute, a);\n\n          _tempB.fromBufferAttribute(morphAttribute, b);\n\n          _tempC.fromBufferAttribute(morphAttribute, c);\n\n          if (morphTargetsRelative) {\n            _morphA.addScaledVector(_tempA, influence);\n\n            _morphB.addScaledVector(_tempB, influence);\n\n            _morphC.addScaledVector(_tempC, influence);\n          } else {\n            _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n            _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n            _morphC.addScaledVector(_tempC.sub(_vC), influence);\n          }\n        }\n\n        _vA.add(_morphA);\n\n        _vB.add(_morphB);\n\n        _vC.add(_morphC);\n      }\n\n      if (object.isSkinnedMesh) {\n        object.boneTransform(a, _vA);\n        object.boneTransform(b, _vB);\n        object.boneTransform(c, _vC);\n      }\n\n      modifiedAttributeArray[a * 3 + 0] = _vA.x;\n      modifiedAttributeArray[a * 3 + 1] = _vA.y;\n      modifiedAttributeArray[a * 3 + 2] = _vA.z;\n      modifiedAttributeArray[b * 3 + 0] = _vB.x;\n      modifiedAttributeArray[b * 3 + 1] = _vB.y;\n      modifiedAttributeArray[b * 3 + 2] = _vB.z;\n      modifiedAttributeArray[c * 3 + 0] = _vC.x;\n      modifiedAttributeArray[c * 3 + 1] = _vC.y;\n      modifiedAttributeArray[c * 3 + 2] = _vC.z;\n    }\n\n    var geometry = object.geometry;\n    var material = object.material;\n    var a, b, c;\n    var index = geometry.index;\n    var positionAttribute = geometry.attributes.position;\n    var morphPosition = geometry.morphAttributes.position;\n    var morphTargetsRelative = geometry.morphTargetsRelative;\n    var normalAttribute = geometry.attributes.normal;\n    var morphNormal = geometry.morphAttributes.position;\n    var groups = geometry.groups;\n    var drawRange = geometry.drawRange;\n    var i, j, il, jl;\n    var group, groupMaterial;\n    var start, end;\n    var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n    if (index !== null) {\n      // indexed buffer geometry\n      if (Array.isArray(material)) {\n        for (i = 0, il = groups.length; i < il; i++) {\n          group = groups[i];\n          groupMaterial = material[group.materialIndex];\n          start = Math.max(group.start, drawRange.start);\n          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n          for (j = start, jl = end; j < jl; j += 3) {\n            a = index.getX(j);\n            b = index.getX(j + 1);\n            c = index.getX(j + 2);\n\n            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n          }\n        }\n      } else {\n        start = Math.max(0, drawRange.start);\n        end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (i = start, il = end; i < il; i += 3) {\n          a = index.getX(i);\n          b = index.getX(i + 1);\n          c = index.getX(i + 2);\n\n          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else if (positionAttribute !== undefined) {\n      // non-indexed buffer geometry\n      if (Array.isArray(material)) {\n        for (i = 0, il = groups.length; i < il; i++) {\n          group = groups[i];\n          groupMaterial = material[group.materialIndex];\n          start = Math.max(group.start, drawRange.start);\n          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n          for (j = start, jl = end; j < jl; j += 3) {\n            a = j;\n            b = j + 1;\n            c = j + 2;\n\n            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n          }\n        }\n      } else {\n        start = Math.max(0, drawRange.start);\n        end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n        for (i = start, il = end; i < il; i += 3) {\n          a = i;\n          b = i + 1;\n          c = i + 2;\n\n          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    }\n\n    var morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n    var morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n    return {\n      positionAttribute: positionAttribute,\n      normalAttribute: normalAttribute,\n      morphedPositionAttribute: morphedPositionAttribute,\n      morphedNormalAttribute: morphedNormalAttribute\n    };\n  }\n};\nexport { BufferGeometryUtils };","map":{"version":3,"sources":["D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"names":["BufferAttribute","BufferGeometry","Float32BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector3","BufferGeometryUtils","computeTangents","geometry","console","warn","mergeBufferGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","i","length","attributesCount","error","name","has","undefined","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","array","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","res","getters","setters","iba","c","k","estimateBytesUsed","mem","attr","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","material","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","il","influence","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","jl","group","groupMaterial","start","end","modifiedPosition","Float32Array","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute"],"mappings":"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","sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3\n} from '../../../build/three.module.js';\n\nvar BufferGeometryUtils = {\n\n\tcomputeTangents: function ( geometry ) {\n\n\t\tgeometry.computeTangents();\n\t\tconsole.warn( 'THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.' );\n\n\t},\n\n\t/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\n\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\n\t\tvar isIndexed = geometries[ 0 ].index !== null;\n\n\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\tvar attributes = {};\n\t\tvar morphAttributes = {};\n\n\t\tvar morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\tvar mergedGeometry = new BufferGeometry();\n\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tvar geometry = geometries[ i ];\n\t\t\tvar attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\n\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfor ( var name in geometry.morphAttributes ) {\n\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather .userData\n\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tvar count;\n\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\n\t\tif ( isIndexed ) {\n\n\t\t\tvar indexOffset = 0;\n\t\t\tvar mergedIndex = [];\n\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tvar index = geometries[ i ].index;\n\n\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t}\n\n\t\t// merge attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\tif ( ! mergedAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t}\n\n\t\t// merge morph attributes\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\tvar morphAttributesToMerge = [];\n\n\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mergedGeometry;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {BufferAttribute}\n\t */\n\tmergeBufferAttributes: function ( attributes ) {\n\n\t\tvar TypedArray;\n\t\tvar itemSize;\n\t\tvar normalized;\n\t\tvar arrayLength = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\n\t\t}\n\n\t\tvar array = new TypedArray( arrayLength );\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\toffset += attributes[ i ].array.length;\n\n\t\t}\n\n\t\treturn new BufferAttribute( array, itemSize, normalized );\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {Array<InterleavedBufferAttribute>}\n\t */\n\tinterleaveAttributes: function ( attributes ) {\n\n\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\tvar TypedArray;\n\t\tvar arrayLength = 0;\n\t\tvar stride = 0;\n\n\t\t// calculate the the length and type of the interleavedBuffer\n\t\tfor ( var i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\t\t\tstride += attribute.itemSize;\n\n\t\t}\n\n\t\t// Create the set of buffer attributes\n\t\tvar interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\tvar offset = 0;\n\t\tvar res = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tvar setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\tfor ( var j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\tvar attribute = attributes[ j ];\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar count = attribute.count;\n\t\t\tvar iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\tres.push( iba );\n\n\t\t\toffset += itemSize;\n\n\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t// at the appropriate offset\n\t\t\tfor ( var c = 0; c < count; c ++ ) {\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferGeometry>} geometry\n\t * @return {number}\n\t */\n\testimateBytesUsed: function ( geometry ) {\n\n\t\t// Return the estimated memory used by this geometry in bytes\n\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t// for InterleavedBufferAttributes.\n\t\tvar mem = 0;\n\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\tvar attr = geometry.getAttribute( name );\n\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t}\n\n\t\tvar indices = geometry.getIndex();\n\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\treturn mem;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} tolerance\n\t * @return {BufferGeometry>}\n\t */\n\tmergeVertices: function ( geometry, tolerance = 1e-4 ) {\n\n\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t// if it's already available.\n\t\tvar hashToIndex = {};\n\t\tvar indices = geometry.getIndex();\n\t\tvar positions = geometry.getAttribute( 'position' );\n\t\tvar vertexCount = indices ? indices.count : positions.count;\n\n\t\t// next value for triangle indices\n\t\tvar nextIndex = 0;\n\n\t\t// attributes and new attribute arrays\n\t\tvar attributeNames = Object.keys( geometry.attributes );\n\t\tvar attrArrays = {};\n\t\tvar morphAttrsArrays = {};\n\t\tvar newIndices = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t// initialize the arrays\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\n\t\t\tattrArrays[ name ] = [];\n\n\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\tif ( morphAttr ) {\n\n\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\tvar decimalShift = Math.log10( 1 / tolerance );\n\t\tvar shiftMultiplier = Math.pow( 10, decimalShift );\n\t\tfor ( var i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tvar index = indices ? indices.getX( i ) : i;\n\n\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\tvar hash = '';\n\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add another reference to the vertex if it's already\n\t\t\t// used by another index\n\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t} else {\n\n\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\t\tvar newarray = attrArrays[ name ];\n\t\t\t\t\tvar newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tvar getterFunc = getters[ k ];\n\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\tnextIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate typed arrays from new attribute arrays and update\n\t\t// the attributeBuffers\n\t\tconst result = geometry.clone();\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\t\t\tvar oldAttribute = geometry.getAttribute( name );\n\n\t\t\tvar buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\tvar attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t// Update the attribute arrays\n\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\tfor ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\tvar oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\tvar buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\tvar morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tresult.setIndex( newIndices );\n\n\t\treturn result;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} drawMode\n\t * @return {BufferGeometry>}\n\t */\n\ttoTrianglesDrawMode: function ( geometry, drawMode ) {\n\n\t\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\tnewGeometry.clearGroups();\n\n\t\t\treturn newGeometry;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n\t * Helpful for Raytracing or Decals.\n\t * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n\t * @return {Object} An Object with original position/normal attributes and morphed ones.\n\t */\n\tcomputeMorphedAttributes: function ( object ) {\n\n\t\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar _vA = new Vector3();\n\t\tvar _vB = new Vector3();\n\t\tvar _vC = new Vector3();\n\n\t\tvar _tempA = new Vector3();\n\t\tvar _tempB = new Vector3();\n\t\tvar _tempC = new Vector3();\n\n\t\tvar _morphA = new Vector3();\n\t\tvar _morphB = new Vector3();\n\t\tvar _morphC = new Vector3();\n\n\t\tfunction _calculateMorphedAttributeData(\n\t\t\tobject,\n\t\t\tmaterial,\n\t\t\tattribute,\n\t\t\tmorphAttribute,\n\t\t\tmorphTargetsRelative,\n\t\t\ta,\n\t\t\tb,\n\t\t\tc,\n\t\t\tmodifiedAttributeArray\n\t\t) {\n\n\t\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\t\tfor ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar influence = morphInfluences[ i ];\n\t\t\t\t\tvar morphAttribute = morphAttribute[ i ];\n\n\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_vA.add( _morphA );\n\t\t\t\t_vB.add( _morphB );\n\t\t\t\t_vC.add( _morphC );\n\n\t\t\t}\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tobject.boneTransform( a, _vA );\n\t\t\t\tobject.boneTransform( b, _vB );\n\t\t\t\tobject.boneTransform( c, _vC );\n\n\t\t\t}\n\n\t\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t\t}\n\n\t\tvar geometry = object.geometry;\n\t\tvar material = object.material;\n\n\t\tvar a, b, c;\n\t\tvar index = geometry.index;\n\t\tvar positionAttribute = geometry.attributes.position;\n\t\tvar morphPosition = geometry.morphAttributes.position;\n\t\tvar morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tvar normalAttribute = geometry.attributes.normal;\n\t\tvar morphNormal = geometry.morphAttributes.position;\n\n\t\tvar groups = geometry.groups;\n\t\tvar drawRange = geometry.drawRange;\n\t\tvar i, j, il, jl;\n\t\tvar group, groupMaterial;\n\t\tvar start, end;\n\n\t\tvar modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\t\tvar modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\ta = index.getX( i );\n\t\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( positionAttribute !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\ta = j;\n\t\t\t\t\t\tb = j + 1;\n\t\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\ta = i;\n\t\t\t\t\tb = i + 1;\n\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\t\tvar morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\t\treturn {\n\n\t\t\tpositionAttribute: positionAttribute,\n\t\t\tnormalAttribute: normalAttribute,\n\t\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t\t};\n\n\t}\n\n};\n\nexport { BufferGeometryUtils };\n"]},"metadata":{},"sourceType":"module"}
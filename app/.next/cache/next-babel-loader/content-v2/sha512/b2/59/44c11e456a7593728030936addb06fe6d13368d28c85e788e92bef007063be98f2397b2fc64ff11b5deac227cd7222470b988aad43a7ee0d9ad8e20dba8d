{"ast":null,"code":"import _classCallCheck from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { MeshStandardMaterial } from 'three';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\n\nvar MeshReflectorMaterial = /*#__PURE__*/function (_MeshStandardMaterial) {\n  _inherits(MeshReflectorMaterial, _MeshStandardMaterial);\n\n  var _super = _createSuper(MeshReflectorMaterial);\n\n  function MeshReflectorMaterial() {\n    var _this;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MeshReflectorMaterial);\n\n    _this = _super.call(this, parameters);\n\n    _defineProperty(_assertThisInitialized(_this), \"_debug\", {\n      value: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_tDepth\", {\n      value: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_tDiffuse\", {\n      value: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_tDiffuseBlur\", {\n      value: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_textureMatrix\", {\n      value: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_hasBlur\", {\n      value: false\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_mirror\", {\n      value: 0.0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_mixBlur\", {\n      value: 0.0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_blurStrength\", {\n      value: 0.5\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_minDepthThreshold\", {\n      value: 0.9\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_maxDepthThreshold\", {\n      value: 1\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_depthScale\", {\n      value: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_depthToBlurRatioBias\", {\n      value: 0.25\n    });\n\n    _this.setValues(parameters);\n\n    return _this;\n  }\n\n  _createClass(MeshReflectorMaterial, [{\n    key: \"onBeforeCompile\",\n    value: function onBeforeCompile(shader) {\n      shader.uniforms.debug = this._debug;\n      shader.uniforms.hasBlur = this._hasBlur;\n      shader.uniforms.tDiffuse = this._tDiffuse;\n      shader.uniforms.tDepth = this._tDepth;\n      shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;\n      shader.uniforms.textureMatrix = this._textureMatrix;\n      shader.uniforms.mirror = this._mirror;\n      shader.uniforms.mixBlur = this._mixBlur;\n      shader.uniforms.mixStrength = this._blurStrength;\n      shader.uniforms.minDepthThreshold = this._minDepthThreshold;\n      shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;\n      shader.uniforms.depthScale = this._depthScale;\n      shader.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias;\n      shader.vertexShader = \"\\n        uniform mat4 textureMatrix;\\n        varying vec4 my_vUv;     \\n      \" + shader.vertexShader;\n      shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', \"#include <project_vertex>\\n        my_vUv = textureMatrix * vec4( position, 1.0 );\\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\");\n      shader.fragmentShader = \"\\n        uniform int debug;\\n        uniform sampler2D tDiffuse;\\n        uniform sampler2D tDiffuseBlur;\\n        uniform sampler2D tDepth;\\n        uniform float cameraNear;\\n\\t\\t\\t  uniform float cameraFar;\\n        uniform bool hasBlur;\\n        uniform float mixBlur;\\n        uniform float mirror;\\n        uniform float mixStrength;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec4 my_vUv;        \\n        \" + shader.fragmentShader;\n      shader.fragmentShader = shader.fragmentShader.replace('#include <emissivemap_fragment>', \"#include <emissivemap_fragment>\\n      \\n      vec4 base = texture2DProj(tDiffuse, my_vUv);\\n      vec4 blur = texture2DProj(tDiffuseBlur, my_vUv);\\n      \\n      vec4 merge = base;\\n      float depthFactor = 0.0001;\\n      float blurFactor = 0.0;\\n\\n      #ifdef USE_DEPTH\\n        vec4 depth = texture2DProj(tDepth, my_vUv);\\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n        depthFactor *= depthScale;\\n        depthFactor = max(0.0001, min(1.0, depthFactor));\\n\\n        #ifdef USE_BLUR\\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\\n          merge = merge * min(1.0, depthFactor + 0.5);;\\n        #else\\n          merge = merge * depthFactor;\\n        #endif\\n  \\n      #endif\\n\\n      float reflectorRoughnessFactor = roughness;\\n      #ifdef USE_ROUGHNESSMAP\\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\\n      #endif\\n      \\n      #ifdef USE_BLUR\\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\\n        merge = mix(merge, blur, blurFactor);\\n      #endif\\n\\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + merge.rgb * mixStrength);           \\n      diffuseColor = sRGBToLinear(diffuseColor);\\n      \\n      if (debug == 1) {\\n        diffuseColor = sRGBToLinear(vec4(vec3(depthFactor), 1.0));\\n      }\\n      if (debug == 2) {\\n        diffuseColor = sRGBToLinear(vec4(vec3(blurFactor), 1.0));\\n      }\\n      if (debug == 3) {\\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuse, my_vUv));\\n      }\\n      if (debug == 4) {\\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuseBlur, my_vUv));\\n      }\\n      \");\n    }\n  }, {\n    key: \"tDiffuse\",\n    get: function get() {\n      return this._tDiffuse.value;\n    },\n    set: function set(v) {\n      this._tDiffuse.value = v;\n    }\n  }, {\n    key: \"tDepth\",\n    get: function get() {\n      return this._tDepth.value;\n    },\n    set: function set(v) {\n      this._tDepth.value = v;\n    }\n  }, {\n    key: \"tDiffuseBlur\",\n    get: function get() {\n      return this._tDiffuseBlur.value;\n    },\n    set: function set(v) {\n      this._tDiffuseBlur.value = v;\n    }\n  }, {\n    key: \"textureMatrix\",\n    get: function get() {\n      return this._textureMatrix.value;\n    },\n    set: function set(v) {\n      this._textureMatrix.value = v;\n    }\n  }, {\n    key: \"hasBlur\",\n    get: function get() {\n      return this._hasBlur.value;\n    },\n    set: function set(v) {\n      this._hasBlur.value = v;\n    }\n  }, {\n    key: \"mirror\",\n    get: function get() {\n      return this._mirror.value;\n    },\n    set: function set(v) {\n      this._mirror.value = v;\n    }\n  }, {\n    key: \"mixBlur\",\n    get: function get() {\n      return this._mixBlur.value;\n    },\n    set: function set(v) {\n      this._mixBlur.value = v;\n    }\n  }, {\n    key: \"mixStrength\",\n    get: function get() {\n      return this._blurStrength.value;\n    },\n    set: function set(v) {\n      this._blurStrength.value = v;\n    }\n  }, {\n    key: \"minDepthThreshold\",\n    get: function get() {\n      return this._minDepthThreshold.value;\n    },\n    set: function set(v) {\n      this._minDepthThreshold.value = v;\n    }\n  }, {\n    key: \"maxDepthThreshold\",\n    get: function get() {\n      return this._maxDepthThreshold.value;\n    },\n    set: function set(v) {\n      this._maxDepthThreshold.value = v;\n    }\n  }, {\n    key: \"depthScale\",\n    get: function get() {\n      return this._depthScale.value;\n    },\n    set: function set(v) {\n      this._depthScale.value = v;\n    }\n  }, {\n    key: \"debug\",\n    get: function get() {\n      return this._debug.value;\n    },\n    set: function set(v) {\n      this._debug.value = v;\n    }\n  }, {\n    key: \"depthToBlurRatioBias\",\n    get: function get() {\n      return this._depthToBlurRatioBias.value;\n    },\n    set: function set(v) {\n      this._depthToBlurRatioBias.value = v;\n    }\n  }]);\n\n  return MeshReflectorMaterial;\n}(MeshStandardMaterial);\n\nexport { MeshReflectorMaterial };","map":{"version":3,"sources":["D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/@react-three/drei/materials/MeshReflectorMaterial.js"],"names":["MeshStandardMaterial","_defineProperty","MeshReflectorMaterial","parameters","value","setValues","shader","uniforms","debug","_debug","hasBlur","_hasBlur","tDiffuse","_tDiffuse","tDepth","_tDepth","tDiffuseBlur","_tDiffuseBlur","textureMatrix","_textureMatrix","mirror","_mirror","mixBlur","_mixBlur","mixStrength","_blurStrength","minDepthThreshold","_minDepthThreshold","maxDepthThreshold","_maxDepthThreshold","depthScale","_depthScale","depthToBlurRatioBias","_depthToBlurRatioBias","vertexShader","replace","fragmentShader","v"],"mappings":"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","sourcesContent":["import { MeshStandardMaterial } from 'three';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\n\nclass MeshReflectorMaterial extends MeshStandardMaterial {\n  constructor(parameters = {}) {\n    super(parameters);\n\n    _defineProperty(this, \"_debug\", {\n      value: 0\n    });\n\n    _defineProperty(this, \"_tDepth\", {\n      value: null\n    });\n\n    _defineProperty(this, \"_tDiffuse\", {\n      value: null\n    });\n\n    _defineProperty(this, \"_tDiffuseBlur\", {\n      value: null\n    });\n\n    _defineProperty(this, \"_textureMatrix\", {\n      value: null\n    });\n\n    _defineProperty(this, \"_hasBlur\", {\n      value: false\n    });\n\n    _defineProperty(this, \"_mirror\", {\n      value: 0.0\n    });\n\n    _defineProperty(this, \"_mixBlur\", {\n      value: 0.0\n    });\n\n    _defineProperty(this, \"_blurStrength\", {\n      value: 0.5\n    });\n\n    _defineProperty(this, \"_minDepthThreshold\", {\n      value: 0.9\n    });\n\n    _defineProperty(this, \"_maxDepthThreshold\", {\n      value: 1\n    });\n\n    _defineProperty(this, \"_depthScale\", {\n      value: 0\n    });\n\n    _defineProperty(this, \"_depthToBlurRatioBias\", {\n      value: 0.25\n    });\n\n    this.setValues(parameters);\n  }\n\n  onBeforeCompile(shader) {\n    shader.uniforms.debug = this._debug;\n    shader.uniforms.hasBlur = this._hasBlur;\n    shader.uniforms.tDiffuse = this._tDiffuse;\n    shader.uniforms.tDepth = this._tDepth;\n    shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;\n    shader.uniforms.textureMatrix = this._textureMatrix;\n    shader.uniforms.mirror = this._mirror;\n    shader.uniforms.mixBlur = this._mixBlur;\n    shader.uniforms.mixStrength = this._blurStrength;\n    shader.uniforms.minDepthThreshold = this._minDepthThreshold;\n    shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;\n    shader.uniforms.depthScale = this._depthScale;\n    shader.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias;\n    shader.vertexShader = \"\\n        uniform mat4 textureMatrix;\\n        varying vec4 my_vUv;     \\n      \" + shader.vertexShader;\n    shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', \"#include <project_vertex>\\n        my_vUv = textureMatrix * vec4( position, 1.0 );\\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\");\n    shader.fragmentShader = \"\\n        uniform int debug;\\n        uniform sampler2D tDiffuse;\\n        uniform sampler2D tDiffuseBlur;\\n        uniform sampler2D tDepth;\\n        uniform float cameraNear;\\n\\t\\t\\t  uniform float cameraFar;\\n        uniform bool hasBlur;\\n        uniform float mixBlur;\\n        uniform float mirror;\\n        uniform float mixStrength;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec4 my_vUv;        \\n        \" + shader.fragmentShader;\n    shader.fragmentShader = shader.fragmentShader.replace('#include <emissivemap_fragment>', \"#include <emissivemap_fragment>\\n      \\n      vec4 base = texture2DProj(tDiffuse, my_vUv);\\n      vec4 blur = texture2DProj(tDiffuseBlur, my_vUv);\\n      \\n      vec4 merge = base;\\n      float depthFactor = 0.0001;\\n      float blurFactor = 0.0;\\n\\n      #ifdef USE_DEPTH\\n        vec4 depth = texture2DProj(tDepth, my_vUv);\\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n        depthFactor *= depthScale;\\n        depthFactor = max(0.0001, min(1.0, depthFactor));\\n\\n        #ifdef USE_BLUR\\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\\n          merge = merge * min(1.0, depthFactor + 0.5);;\\n        #else\\n          merge = merge * depthFactor;\\n        #endif\\n  \\n      #endif\\n\\n      float reflectorRoughnessFactor = roughness;\\n      #ifdef USE_ROUGHNESSMAP\\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\\n      #endif\\n      \\n      #ifdef USE_BLUR\\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\\n        merge = mix(merge, blur, blurFactor);\\n      #endif\\n\\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + merge.rgb * mixStrength);           \\n      diffuseColor = sRGBToLinear(diffuseColor);\\n      \\n      if (debug == 1) {\\n        diffuseColor = sRGBToLinear(vec4(vec3(depthFactor), 1.0));\\n      }\\n      if (debug == 2) {\\n        diffuseColor = sRGBToLinear(vec4(vec3(blurFactor), 1.0));\\n      }\\n      if (debug == 3) {\\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuse, my_vUv));\\n      }\\n      if (debug == 4) {\\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuseBlur, my_vUv));\\n      }\\n      \");\n  }\n\n  get tDiffuse() {\n    return this._tDiffuse.value;\n  }\n\n  set tDiffuse(v) {\n    this._tDiffuse.value = v;\n  }\n\n  get tDepth() {\n    return this._tDepth.value;\n  }\n\n  set tDepth(v) {\n    this._tDepth.value = v;\n  }\n\n  get tDiffuseBlur() {\n    return this._tDiffuseBlur.value;\n  }\n\n  set tDiffuseBlur(v) {\n    this._tDiffuseBlur.value = v;\n  }\n\n  get textureMatrix() {\n    return this._textureMatrix.value;\n  }\n\n  set textureMatrix(v) {\n    this._textureMatrix.value = v;\n  }\n\n  get hasBlur() {\n    return this._hasBlur.value;\n  }\n\n  set hasBlur(v) {\n    this._hasBlur.value = v;\n  }\n\n  get mirror() {\n    return this._mirror.value;\n  }\n\n  set mirror(v) {\n    this._mirror.value = v;\n  }\n\n  get mixBlur() {\n    return this._mixBlur.value;\n  }\n\n  set mixBlur(v) {\n    this._mixBlur.value = v;\n  }\n\n  get mixStrength() {\n    return this._blurStrength.value;\n  }\n\n  set mixStrength(v) {\n    this._blurStrength.value = v;\n  }\n\n  get minDepthThreshold() {\n    return this._minDepthThreshold.value;\n  }\n\n  set minDepthThreshold(v) {\n    this._minDepthThreshold.value = v;\n  }\n\n  get maxDepthThreshold() {\n    return this._maxDepthThreshold.value;\n  }\n\n  set maxDepthThreshold(v) {\n    this._maxDepthThreshold.value = v;\n  }\n\n  get depthScale() {\n    return this._depthScale.value;\n  }\n\n  set depthScale(v) {\n    this._depthScale.value = v;\n  }\n\n  get debug() {\n    return this._debug.value;\n  }\n\n  set debug(v) {\n    this._debug.value = v;\n  }\n\n  get depthToBlurRatioBias() {\n    return this._depthToBlurRatioBias.value;\n  }\n\n  set depthToBlurRatioBias(v) {\n    this._depthToBlurRatioBias.value = v;\n  }\n\n}\n\nexport { MeshReflectorMaterial };\n"]},"metadata":{},"sourceType":"module"}
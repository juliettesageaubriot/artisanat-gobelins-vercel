{"ast":null,"code":"import _classCallCheck from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { ShaderMaterial, Vector2, Uniform, NoBlending } from 'three';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\n\nvar ConvolutionMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(ConvolutionMaterial, _ShaderMaterial);\n\n  var _super = _createSuper(ConvolutionMaterial);\n\n  function ConvolutionMaterial() {\n    var _this;\n\n    var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();\n\n    _classCallCheck(this, ConvolutionMaterial);\n\n    _this = _super.call(this, {\n      uniforms: {\n        inputBuffer: new Uniform(null),\n        depthBuffer: new Uniform(null),\n        resolution: new Uniform(new Vector2()),\n        texelSize: new Uniform(new Vector2()),\n        halfTexelSize: new Uniform(new Vector2()),\n        kernel: new Uniform(0.0),\n        scale: new Uniform(1.0),\n        cameraNear: new Uniform(0.0),\n        cameraFar: new Uniform(1.0),\n        minDepthThreshold: new Uniform(0.0),\n        maxDepthThreshold: new Uniform(1.0),\n        depthScale: new Uniform(0.0),\n        depthToBlurRatioBias: new Uniform(0.25)\n      },\n      fragmentShader: \"#include <common>\\n        #include <dithering_pars_fragment>      \\n        uniform sampler2D inputBuffer;\\n        uniform sampler2D depthBuffer;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          float depthFactor = 0.0;\\n          \\n          #ifdef USE_DEPTH\\n            vec4 depth = texture2D(depthBuffer, vUv);\\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n            depthFactor *= depthScale;\\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\\n          #endif\\n          \\n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\\n          gl_FragColor = sum * 0.25 ;\\n\\n          #include <dithering_fragment>\\n        }\",\n      vertexShader: \"uniform vec2 texelSize;\\n        uniform vec2 halfTexelSize;\\n        uniform float kernel;\\n        uniform float scale;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          vec2 uv = position.xy * 0.5 + 0.5;\\n          vUv = uv;\\n\\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\\n\\n          gl_Position = vec4(position.xy, 1.0, 1.0);\\n        }\",\n      blending: NoBlending,\n      depthWrite: false,\n      depthTest: false\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"kernel\", void 0);\n\n    _this.toneMapped = false;\n\n    _this.setTexelSize(texelSize.x, texelSize.y);\n\n    _this.kernel = new Float32Array([0.0, 1.0, 2.0, 2.0, 3.0]);\n    return _this;\n  }\n\n  _createClass(ConvolutionMaterial, [{\n    key: \"setTexelSize\",\n    value: function setTexelSize(x, y) {\n      this.uniforms.texelSize.value.set(x, y);\n      this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);\n    }\n  }, {\n    key: \"setResolution\",\n    value: function setResolution(resolution) {\n      this.uniforms.resolution.value.copy(resolution);\n    }\n  }]);\n\n  return ConvolutionMaterial;\n}(ShaderMaterial);\n\nexport { ConvolutionMaterial };","map":{"version":3,"sources":["D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/@react-three/drei/materials/ConvolutionMaterial.js"],"names":["ShaderMaterial","Vector2","Uniform","NoBlending","_defineProperty","ConvolutionMaterial","texelSize","uniforms","inputBuffer","depthBuffer","resolution","halfTexelSize","kernel","scale","cameraNear","cameraFar","minDepthThreshold","maxDepthThreshold","depthScale","depthToBlurRatioBias","fragmentShader","vertexShader","blending","depthWrite","depthTest","toneMapped","setTexelSize","x","y","Float32Array","value","set","multiplyScalar","copy"],"mappings":";;;;;;;;;;;AAAA,SAASA,cAAT,EAAyBC,OAAzB,EAAkCC,OAAlC,EAA2CC,UAA3C,QAA6D,OAA7D;AACA,OAAOC,eAAP,MAA4B,2CAA5B;;IAEMC,mB;;;;;AACJ,iCAAuC;AAAA;;AAAA,QAA3BC,SAA2B,uEAAf,IAAIL,OAAJ,EAAe;;AAAA;;AACrC,8BAAM;AACJM,MAAAA,QAAQ,EAAE;AACRC,QAAAA,WAAW,EAAE,IAAIN,OAAJ,CAAY,IAAZ,CADL;AAERO,QAAAA,WAAW,EAAE,IAAIP,OAAJ,CAAY,IAAZ,CAFL;AAGRQ,QAAAA,UAAU,EAAE,IAAIR,OAAJ,CAAY,IAAID,OAAJ,EAAZ,CAHJ;AAIRK,QAAAA,SAAS,EAAE,IAAIJ,OAAJ,CAAY,IAAID,OAAJ,EAAZ,CAJH;AAKRU,QAAAA,aAAa,EAAE,IAAIT,OAAJ,CAAY,IAAID,OAAJ,EAAZ,CALP;AAMRW,QAAAA,MAAM,EAAE,IAAIV,OAAJ,CAAY,GAAZ,CANA;AAORW,QAAAA,KAAK,EAAE,IAAIX,OAAJ,CAAY,GAAZ,CAPC;AAQRY,QAAAA,UAAU,EAAE,IAAIZ,OAAJ,CAAY,GAAZ,CARJ;AASRa,QAAAA,SAAS,EAAE,IAAIb,OAAJ,CAAY,GAAZ,CATH;AAURc,QAAAA,iBAAiB,EAAE,IAAId,OAAJ,CAAY,GAAZ,CAVX;AAWRe,QAAAA,iBAAiB,EAAE,IAAIf,OAAJ,CAAY,GAAZ,CAXX;AAYRgB,QAAAA,UAAU,EAAE,IAAIhB,OAAJ,CAAY,GAAZ,CAZJ;AAaRiB,QAAAA,oBAAoB,EAAE,IAAIjB,OAAJ,CAAY,IAAZ;AAbd,OADN;AAgBJkB,MAAAA,cAAc,EAAE,ixCAhBZ;AAiBJC,MAAAA,YAAY,EAAE,isBAjBV;AAkBJC,MAAAA,QAAQ,EAAEnB,UAlBN;AAmBJoB,MAAAA,UAAU,EAAE,KAnBR;AAoBJC,MAAAA,SAAS,EAAE;AApBP,KAAN;;AAuBApB,IAAAA,eAAe,gCAAO,QAAP,EAAiB,KAAK,CAAtB,CAAf;;AAEA,UAAKqB,UAAL,GAAkB,KAAlB;;AACA,UAAKC,YAAL,CAAkBpB,SAAS,CAACqB,CAA5B,EAA+BrB,SAAS,CAACsB,CAAzC;;AACA,UAAKhB,MAAL,GAAc,IAAIiB,YAAJ,CAAiB,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,CAAjB,CAAd;AA5BqC;AA6BtC;;;;iCAEYF,C,EAAGC,C,EAAG;AACjB,WAAKrB,QAAL,CAAcD,SAAd,CAAwBwB,KAAxB,CAA8BC,GAA9B,CAAkCJ,CAAlC,EAAqCC,CAArC;AACA,WAAKrB,QAAL,CAAcI,aAAd,CAA4BmB,KAA5B,CAAkCC,GAAlC,CAAsCJ,CAAtC,EAAyCC,CAAzC,EAA4CI,cAA5C,CAA2D,GAA3D;AACD;;;kCAEatB,U,EAAY;AACxB,WAAKH,QAAL,CAAcG,UAAd,CAAyBoB,KAAzB,CAA+BG,IAA/B,CAAoCvB,UAApC;AACD;;;;EAvC+BV,c;;AA2ClC,SAASK,mBAAT","sourcesContent":["import { ShaderMaterial, Vector2, Uniform, NoBlending } from 'three';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\n\nclass ConvolutionMaterial extends ShaderMaterial {\n  constructor(texelSize = new Vector2()) {\n    super({\n      uniforms: {\n        inputBuffer: new Uniform(null),\n        depthBuffer: new Uniform(null),\n        resolution: new Uniform(new Vector2()),\n        texelSize: new Uniform(new Vector2()),\n        halfTexelSize: new Uniform(new Vector2()),\n        kernel: new Uniform(0.0),\n        scale: new Uniform(1.0),\n        cameraNear: new Uniform(0.0),\n        cameraFar: new Uniform(1.0),\n        minDepthThreshold: new Uniform(0.0),\n        maxDepthThreshold: new Uniform(1.0),\n        depthScale: new Uniform(0.0),\n        depthToBlurRatioBias: new Uniform(0.25)\n      },\n      fragmentShader: \"#include <common>\\n        #include <dithering_pars_fragment>      \\n        uniform sampler2D inputBuffer;\\n        uniform sampler2D depthBuffer;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          float depthFactor = 0.0;\\n          \\n          #ifdef USE_DEPTH\\n            vec4 depth = texture2D(depthBuffer, vUv);\\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n            depthFactor *= depthScale;\\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\\n          #endif\\n          \\n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\\n          gl_FragColor = sum * 0.25 ;\\n\\n          #include <dithering_fragment>\\n        }\",\n      vertexShader: \"uniform vec2 texelSize;\\n        uniform vec2 halfTexelSize;\\n        uniform float kernel;\\n        uniform float scale;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          vec2 uv = position.xy * 0.5 + 0.5;\\n          vUv = uv;\\n\\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\\n\\n          gl_Position = vec4(position.xy, 1.0, 1.0);\\n        }\",\n      blending: NoBlending,\n      depthWrite: false,\n      depthTest: false\n    });\n\n    _defineProperty(this, \"kernel\", void 0);\n\n    this.toneMapped = false;\n    this.setTexelSize(texelSize.x, texelSize.y);\n    this.kernel = new Float32Array([0.0, 1.0, 2.0, 2.0, 3.0]);\n  }\n\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n    this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);\n  }\n\n  setResolution(resolution) {\n    this.uniforms.resolution.value.copy(resolution);\n  }\n\n}\n\nexport { ConvolutionMaterial };\n"]},"metadata":{},"sourceType":"module"}
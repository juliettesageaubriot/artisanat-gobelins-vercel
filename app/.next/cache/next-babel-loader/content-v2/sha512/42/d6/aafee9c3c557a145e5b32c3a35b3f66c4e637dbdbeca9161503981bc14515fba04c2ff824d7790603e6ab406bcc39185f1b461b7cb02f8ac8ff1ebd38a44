{"ast":null,"code":"// Original src: https://github.com/zz85/threejs-path-flow\nconst BITS = 3;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\nimport { DataTexture, RGBFormat, FloatType, RepeatWrapping, Mesh, InstancedMesh, NearestFilter, DynamicDrawUsage, Matrix4 } from '../../../build/three.module.js';\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\n\nexport function initSplineTexture(numberOfCurves = 1) {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapY = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n}\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\n\nexport function updateSplineTexture(texture, splineCurve, offset = 0) {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n\n  texture.needsUpdate = true;\n}\n\nfunction setTextureValue(texture, index, x, y, z, o) {\n  const image = texture.image;\n  const {\n    data\n  } = image;\n  const i = BITS * TEXTURE_WIDTH * o; // Row Offset\n\n  data[index * BITS + i + 0] = x;\n  data[index * BITS + i + 1] = y;\n  data[index * BITS + i + 2] = z;\n}\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\n\n\nexport function getUniforms(splineTexture) {\n  const uniforms = {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: 'f',\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: 'f',\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: 'f',\n      value: 161\n    },\n    spineLength: {\n      type: 'f',\n      value: 400\n    },\n    flow: {\n      type: 'i',\n      value: 1\n    }\n  };\n  return uniforms;\n}\nexport function modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok) return;\n  material.__ok = true;\n\n  material.onBeforeCompile = shader => {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader = `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t` // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', '') // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/, `\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace('#include <project_vertex>', `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\n    shader.vertexShader = vertexShader;\n  };\n}\n/**\n * A helper class for making meshes bend aroudn curves\n */\n\nexport class Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse(function (child) {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n\n}\nconst matrix = new Matrix4();\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\n\nexport class InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    super(mesh, curveCount);\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n\n\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n\n\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n\n\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n\n}","map":{"version":3,"sources":["D:/AA_CLASS/COURS GOBELINS DMII1/ARTISANAT/artisanat-gobelins-vercel/app/node_modules/three/examples/jsm/modifiers/CurveModifier.js"],"names":["BITS","TEXTURE_WIDTH","TEXTURE_HEIGHT","DataTexture","RGBFormat","FloatType","RepeatWrapping","Mesh","InstancedMesh","NearestFilter","DynamicDrawUsage","Matrix4","initSplineTexture","numberOfCurves","dataArray","Float32Array","dataTexture","wrapS","wrapY","magFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","getUniforms","splineTexture","uniforms","spineTexture","value","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","__ok","onBeforeCompile","shader","__modified","Object","assign","vertexShader","replace","Flow","constructor","mesh","obj3D","clone","splineTexure","traverse","child","curveArray","Array","curveLengthArray","object3D","updateCurve","curve","length","Error","curveLength","getLength","moveAlongCurve","amount","matrix","InstancedFlow","count","curveCount","geometry","instanceMatrix","setUsage","offsets","fill","whichCurve","writeChanges","makeTranslation","setMatrixAt","moveIndividualAlongCurve","setCurve","curveNo","isNaN"],"mappings":"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","sourcesContent":["// Original src: https://github.com/zz85/threejs-path-flow\nconst BITS = 3;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\nimport {\n\tDataTexture,\n\tRGBFormat,\n\tFloatType,\n\tRepeatWrapping,\n\tMesh,\n\tInstancedMesh,\n\tNearestFilter,\n\tDynamicDrawUsage,\n\tMatrix4\n} from '../../../build/three.module.js';\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nexport function initSplineTexture( numberOfCurves = 1 ) {\n\n\tconst dataArray = new Float32Array( TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS );\n\tconst dataTexture = new DataTexture(\n\t\tdataArray,\n\t\tTEXTURE_WIDTH,\n\t\tTEXTURE_HEIGHT * numberOfCurves,\n\t\tRGBFormat,\n\t\tFloatType\n\t);\n\n\tdataTexture.wrapS = RepeatWrapping;\n\tdataTexture.wrapY = RepeatWrapping;\n\tdataTexture.magFilter = NearestFilter;\n\tdataTexture.needsUpdate = true;\n\n\treturn dataTexture;\n\n}\n\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\nexport function updateSplineTexture( texture, splineCurve, offset = 0 ) {\n\n\tconst numberOfPoints = Math.floor( TEXTURE_WIDTH * ( TEXTURE_HEIGHT / 4 ) );\n\tsplineCurve.arcLengthDivisions = numberOfPoints / 2;\n\tsplineCurve.updateArcLengths();\n\tconst points = splineCurve.getSpacedPoints( numberOfPoints );\n\tconst frenetFrames = splineCurve.computeFrenetFrames( numberOfPoints, true );\n\n\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\n\n\t\tconst rowOffset = Math.floor( i / TEXTURE_WIDTH );\n\t\tconst rowIndex = i % TEXTURE_WIDTH;\n\n\t\tlet pt = points[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.tangents[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.normals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\t\tpt = frenetFrames.binormals[ i ];\n\t\tsetTextureValue( texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + ( TEXTURE_HEIGHT * offset ) );\n\n\t}\n\n\ttexture.needsUpdate = true;\n\n}\n\n\nfunction setTextureValue( texture, index, x, y, z, o ) {\n\n\tconst image = texture.image;\n\tconst { data } = image;\n\tconst i = BITS * TEXTURE_WIDTH * o; // Row Offset\n\tdata[ index * BITS + i + 0 ] = x;\n\tdata[ index * BITS + i + 1 ] = y;\n\tdata[ index * BITS + i + 2 ] = z;\n\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nexport function getUniforms( splineTexture ) {\n\n\tconst uniforms = {\n\t\tspineTexture: { value: splineTexture },\n\t\tpathOffset: { type: 'f', value: 0 }, // time of path curve\n\t\tpathSegment: { type: 'f', value: 1 }, // fractional length of path\n\t\tspineOffset: { type: 'f', value: 161 },\n\t\tspineLength: { type: 'f', value: 400 },\n\t\tflow: { type: 'i', value: 1 },\n\t};\n\treturn uniforms;\n\n}\n\nexport function modifyShader( material, uniforms, numberOfCurves = 1 ) {\n\n\tif ( material.__ok ) return;\n\tmaterial.__ok = true;\n\n\tmaterial.onBeforeCompile = ( shader ) => {\n\n\t\tif ( shader.__modified ) return;\n\t\tshader.__modified = true;\n\n\t\tObject.assign( shader.uniforms, uniforms );\n\n\t\tconst vertexShader = `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`\n\t\t// chunk import moved in front of modified shader below\n\t\t\t.replace( '#include <beginnormal_vertex>', '' )\n\n\t\t\t// vec3 transformedNormal declaration overriden below\n\t\t\t.replace( '#include <defaultnormal_vertex>', '' )\n\n\t\t\t// vec3 transformed declaration overriden below\n\t\t\t.replace( '#include <begin_vertex>', '' )\n\n\t\t\t// shader override\n\t\t\t.replace(\n\t\t\t\t/void\\s*main\\s*\\(\\)\\s*\\{/,\n\t\t\t\t`\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t` ).replace(\n\t\t\t\t'#include <project_vertex>',\n\t\t\t\t`vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`\n\t\t\t);\n\n\t\tshader.vertexShader = vertexShader;\n\n\t};\n\n}\n\n/**\n * A helper class for making meshes bend aroudn curves\n */\nexport class Flow {\n\n\t/**\n\t * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n\t * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n\t */\n\tconstructor( mesh, numberOfCurves = 1 ) {\n\n\t\tconst obj3D = mesh.clone();\n\t\tconst splineTexure = initSplineTexture( numberOfCurves );\n\t\tconst uniforms = getUniforms( splineTexure );\n\t\tobj3D.traverse( function ( child ) {\n\n\t\t\tif (\n\t\t\t\tchild instanceof Mesh ||\n\t\t\t\tchild instanceof InstancedMesh\n\t\t\t) {\n\n\t\t\t\tchild.material = child.material.clone();\n\t\t\t\tmodifyShader( child.material, uniforms, numberOfCurves );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.curveArray = new Array( numberOfCurves );\n\t\tthis.curveLengthArray = new Array( numberOfCurves );\n\n\t\tthis.object3D = obj3D;\n\t\tthis.splineTexure = splineTexure;\n\t\tthis.uniforms = uniforms;\n\n\t}\n\n\tupdateCurve( index, curve ) {\n\n\t\tif ( index >= this.curveArray.length ) throw Error( 'Index out of range for Flow' );\n\t\tconst curveLength = curve.getLength();\n\t\tthis.uniforms.spineLength.value = curveLength;\n\t\tthis.curveLengthArray[ index ] = curveLength;\n\t\tthis.curveArray[ index ] = curve;\n\t\tupdateSplineTexture( this.splineTexure, curve, index );\n\n\t}\n\n\tmoveAlongCurve( amount ) {\n\n\t\tthis.uniforms.pathOffset.value += amount;\n\n\t}\n\n}\nconst matrix = new Matrix4();\n\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\nexport class InstancedFlow extends Flow {\n\n\t/**\n\t *\n\t * @param {number} count The number of instanced elements\n\t * @param {number} curveCount The number of curves to preallocate for\n\t * @param {Geometry} geometry The geometry to use for the instanced mesh\n\t * @param {Material} material The material to use for the instanced mesh\n\t */\n\tconstructor( count, curveCount, geometry, material ) {\n\n\t\tconst mesh = new InstancedMesh(\n\t\t\tgeometry,\n\t\t\tmaterial,\n\t\t\tcount\n\t\t);\n\t\tmesh.instanceMatrix.setUsage( DynamicDrawUsage );\n\t\tsuper( mesh, curveCount );\n\n\t\tthis.offsets = new Array( count ).fill( 0 );\n\t\tthis.whichCurve = new Array( count ).fill( 0 );\n\n\t}\n\n\t/**\n\t * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n\t * This writes that information to the matrix and marks it as needing update.\n\t *\n\t * @param {number} index of the instanced element to update\n\t */\n\twriteChanges( index ) {\n\n\t\tmatrix.makeTranslation(\n\t\t\tthis.curveLengthArray[ this.whichCurve[ index ] ],\n\t\t\tthis.whichCurve[ index ],\n\t\t\tthis.offsets[ index ]\n\t\t);\n\t\tthis.object3D.setMatrixAt( index, matrix );\n\t\tthis.object3D.instanceMatrix.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * Move an individual element along the curve by a specific amount\n\t *\n\t * @param {number} index Which element to update\n\t * @param {number} offset Move by how much\n\t */\n\tmoveIndividualAlongCurve( index, offset ) {\n\n\t\tthis.offsets[ index ] += offset;\n\t\tthis.writeChanges( index );\n\n\t}\n\n\t/**\n\t * Select which curve to use for an element\n\t *\n\t * @param {number} index the index of the instanced element to update\n\t * @param {number} curveNo the index of the curve it should use\n\t */\n\tsetCurve( index, curveNo ) {\n\n\t\tif ( isNaN( curveNo ) ) throw Error( 'curve index being set is Not a Number (NaN)' );\n\t\tthis.whichCurve[ index ] = curveNo;\n\t\tthis.writeChanges( index );\n\n\t}\n\n}\n"]},"metadata":{},"sourceType":"module"}
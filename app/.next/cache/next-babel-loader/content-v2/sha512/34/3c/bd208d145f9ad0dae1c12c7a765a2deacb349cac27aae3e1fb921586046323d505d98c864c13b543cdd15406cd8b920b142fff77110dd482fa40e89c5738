{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Vector3 } from '../../../build/three.module.js';\nimport { BufferGeometryUtils } from '../utils/BufferGeometryUtils.js';\n\nvar EdgeSplitModifier = function () {\n  var A = new Vector3();\n  var B = new Vector3();\n  var C = new Vector3();\n  var positions, normals;\n  var indexes;\n  var pointToIndexMap, splitIndexes;\n  let oldNormals;\n\n  function computeNormals() {\n    normals = new Float32Array(indexes.length * 3);\n\n    for (var i = 0; i < indexes.length; i += 3) {\n      var index = indexes[i];\n      A.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      index = indexes[i + 1];\n      B.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      index = indexes[i + 2];\n      C.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      C.sub(B);\n      A.sub(B);\n      var normal = C.cross(A).normalize();\n\n      for (var j = 0; j < 3; j++) {\n        normals[3 * (i + j)] = normal.x;\n        normals[3 * (i + j) + 1] = normal.y;\n        normals[3 * (i + j) + 2] = normal.z;\n      }\n    }\n  }\n\n  function mapPositionsToIndexes() {\n    pointToIndexMap = Array(positions.length / 3);\n\n    for (var i = 0; i < indexes.length; i++) {\n      var index = indexes[i];\n\n      if (pointToIndexMap[index] == null) {\n        pointToIndexMap[index] = [];\n      }\n\n      pointToIndexMap[index].push(i);\n    }\n  }\n\n  function edgeSplitToGroups(indexes, cutOff, firstIndex) {\n    A.set(normals[3 * firstIndex], normals[3 * firstIndex + 1], normals[3 * firstIndex + 2]).normalize();\n    var result = {\n      splitGroup: [],\n      currentGroup: [firstIndex]\n    };\n\n    for (var j of indexes) {\n      if (j !== firstIndex) {\n        B.set(normals[3 * j], normals[3 * j + 1], normals[3 * j + 2]).normalize();\n\n        if (B.dot(A) < cutOff) {\n          result.splitGroup.push(j);\n        } else {\n          result.currentGroup.push(j);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function edgeSplit(indexes, cutOff, original = null) {\n    if (indexes.length === 0) return;\n    var groupResults = [];\n\n    for (var index of indexes) {\n      groupResults.push(edgeSplitToGroups(indexes, cutOff, index));\n    }\n\n    var result = groupResults[0];\n\n    for (var groupResult of groupResults) {\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult;\n      }\n    }\n\n    if (original != null) {\n      splitIndexes.push({\n        original: original,\n        indexes: result.currentGroup\n      });\n    }\n\n    if (result.splitGroup.length) {\n      edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n    }\n  }\n\n  this.modify = function (geometry, cutOffAngle, tryKeepNormals = true) {\n    const wasNotBufferGeometry = geometry.isBufferGeometry === undefined;\n\n    if (!geometry.isBufferGeometry) {\n      geometry = new BufferGeometry().fromGeometry(geometry);\n    }\n\n    let hadNormals = false;\n    oldNormals = null;\n\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      if (wasNotBufferGeometry === false) geometry = geometry.clone();\n      if (tryKeepNormals && geometry.index) oldNormals = geometry.attributes.normal.array;\n      geometry.deleteAttribute('normal');\n    }\n\n    if (!geometry.index) {\n      if (BufferGeometryUtils === undefined) {\n        throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n      }\n\n      geometry = BufferGeometryUtils.mergeVertices(geometry);\n    }\n\n    indexes = geometry.index.array;\n    positions = geometry.getAttribute('position').array;\n    computeNormals();\n    mapPositionsToIndexes();\n    splitIndexes = [];\n\n    for (var vertexIndexes of pointToIndexMap) {\n      edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n    }\n\n    const newAttributes = {};\n\n    for (const name of Object.keys(geometry.attributes)) {\n      const oldAttribute = geometry.attributes[name];\n      const newArray = new oldAttribute.array.constructor((indexes.length + splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n\n    var newIndexes = new Uint32Array(indexes.length);\n    newIndexes.set(indexes);\n\n    for (var i = 0; i < splitIndexes.length; i++) {\n      var split = splitIndexes[i];\n      var index = indexes[split.original];\n\n      for (const attribute of Object.values(newAttributes)) {\n        for (let j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n\n      for (var j of split.indexes) {\n        newIndexes[j] = indexes.length + i;\n      }\n    }\n\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n\n    for (const name of Object.keys(newAttributes)) {\n      geometry.setAttribute(name, newAttributes[name]);\n    }\n\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n\n      if (oldNormals !== null) {\n        const changedNormals = new Array(oldNormals.length / 3).fill(false);\n\n        for (const splitData of splitIndexes) changedNormals[splitData.original] = true;\n\n        for (let i = 0; i < changedNormals.length; i++) {\n          if (changedNormals[i] === false) {\n            for (let j = 0; j < 3; j++) geometry.attributes.normal.array[3 * i + j] = oldNormals[3 * i + j];\n          }\n        }\n      }\n    }\n\n    return geometry;\n  };\n};\n\nexport { EdgeSplitModifier };","map":{"version":3,"sources":["/Users/juliette/Sites/localhost/GOBELINS/next.js/examples/with-three-js/node_modules/three/examples/jsm/modifiers/EdgeSplitModifier.js"],"names":["BufferAttribute","BufferGeometry","Vector3","BufferGeometryUtils","EdgeSplitModifier","A","B","C","positions","normals","indexes","pointToIndexMap","splitIndexes","oldNormals","computeNormals","Float32Array","length","i","index","set","sub","normal","cross","normalize","j","x","y","z","mapPositionsToIndexes","Array","push","edgeSplitToGroups","cutOff","firstIndex","result","splitGroup","currentGroup","dot","edgeSplit","original","groupResults","groupResult","modify","geometry","cutOffAngle","tryKeepNormals","wasNotBufferGeometry","isBufferGeometry","undefined","fromGeometry","hadNormals","attributes","clone","array","deleteAttribute","mergeVertices","getAttribute","vertexIndexes","Math","cos","newAttributes","name","Object","keys","oldAttribute","newArray","constructor","itemSize","normalized","newIndexes","Uint32Array","split","attribute","values","setIndex","setAttribute","computeVertexNormals","changedNormals","fill","splitData"],"mappings":"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","sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tVector3\n} from '../../../build/three.module.js';\nimport { BufferGeometryUtils } from '../utils/BufferGeometryUtils.js';\n\n\nvar EdgeSplitModifier = function () {\n\n\tvar A = new Vector3();\n\tvar B = new Vector3();\n\tvar C = new Vector3();\n\n\tvar positions, normals;\n\tvar indexes;\n\tvar pointToIndexMap, splitIndexes;\n\n\tlet oldNormals;\n\n\n\tfunction computeNormals() {\n\n\t\tnormals = new Float32Array( indexes.length * 3 );\n\n\t\tfor ( var i = 0; i < indexes.length; i += 3 ) {\n\n\t\t\tvar index = indexes[ i ];\n\n\t\t\tA.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tindex = indexes[ i + 1 ];\n\t\t\tB.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tindex = indexes[ i + 2 ];\n\t\t\tC.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tC.sub( B );\n\t\t\tA.sub( B );\n\n\t\t\tvar normal = C.cross( A ).normalize();\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tnormals[ 3 * ( i + j ) ] = normal.x;\n\t\t\t\tnormals[ 3 * ( i + j ) + 1 ] = normal.y;\n\t\t\t\tnormals[ 3 * ( i + j ) + 2 ] = normal.z;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction mapPositionsToIndexes() {\n\n\t\tpointToIndexMap = Array( positions.length / 3 );\n\n\t\tfor ( var i = 0; i < indexes.length; i ++ ) {\n\n\t\t\tvar index = indexes[ i ];\n\n\t\t\tif ( pointToIndexMap[ index ] == null ) {\n\n\t\t\t\tpointToIndexMap[ index ] = [];\n\n\t\t\t}\n\n\t\t\tpointToIndexMap[ index ].push( i );\n\n\t\t}\n\n\t}\n\n\n\tfunction edgeSplitToGroups( indexes, cutOff, firstIndex ) {\n\n\t\tA.set( normals[ 3 * firstIndex ], normals[ 3 * firstIndex + 1 ], normals[ 3 * firstIndex + 2 ] ).normalize();\n\n\t\tvar result = {\n\t\t\tsplitGroup: [],\n\t\t\tcurrentGroup: [ firstIndex ]\n\t\t};\n\n\t\tfor ( var j of indexes ) {\n\n\t\t\tif ( j !== firstIndex ) {\n\n\t\t\t\tB.set( normals[ 3 * j ], normals[ 3 * j + 1 ], normals[ 3 * j + 2 ] ).normalize();\n\n\t\t\t\tif ( B.dot( A ) < cutOff ) {\n\n\t\t\t\t\tresult.splitGroup.push( j );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult.currentGroup.push( j );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\n\tfunction edgeSplit( indexes, cutOff, original = null ) {\n\n\t\tif ( indexes.length === 0 ) return;\n\n\t\tvar groupResults = [];\n\n\t\tfor ( var index of indexes ) {\n\n\t\t\tgroupResults.push( edgeSplitToGroups( indexes, cutOff, index ) );\n\n\t\t}\n\n\t\tvar result = groupResults[ 0 ];\n\n\t\tfor ( var groupResult of groupResults ) {\n\n\t\t\tif ( groupResult.currentGroup.length > result.currentGroup.length ) {\n\n\t\t\t\tresult = groupResult;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( original != null ) {\n\n\t\t\tsplitIndexes.push( {\n\t\t\t\toriginal: original,\n\t\t\t\tindexes: result.currentGroup\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( result.splitGroup.length ) {\n\n\t\t\tedgeSplit( result.splitGroup, cutOff, original || result.currentGroup[ 0 ] );\n\n\t\t}\n\n\t}\n\n\n\tthis.modify = function ( geometry, cutOffAngle, tryKeepNormals = true ) {\n\n\t\tconst wasNotBufferGeometry = geometry.isBufferGeometry === undefined;\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new BufferGeometry().fromGeometry( geometry );\n\n\t\t}\n\n\n\t\tlet hadNormals = false;\n\t\toldNormals = null;\n\t\tif ( geometry.attributes.normal ) {\n\n\t\t\thadNormals = true;\n\n\t\t\tif ( wasNotBufferGeometry === false )\n\t\t\t\tgeometry = geometry.clone();\n\n\t\t\tif ( tryKeepNormals && geometry.index )\n\t\t\t\toldNormals = geometry.attributes.normal.array;\n\n\t\t\tgeometry.deleteAttribute( 'normal' );\n\n\t\t}\n\n\n\t\tif ( ! geometry.index ) {\n\n\t\t\tif ( BufferGeometryUtils === undefined ) {\n\n\t\t\t \tthrow 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n\n\t\t\t}\n\n\t\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t}\n\n\t\tindexes = geometry.index.array;\n\t\tpositions = geometry.getAttribute( 'position' ).array;\n\n\t\tcomputeNormals();\n\t\tmapPositionsToIndexes();\n\n\t\tsplitIndexes = [];\n\n\t\tfor ( var vertexIndexes of pointToIndexMap ) {\n\n\t\t\tedgeSplit( vertexIndexes, Math.cos( cutOffAngle ) - 0.001 );\n\n\t\t}\n\n\t\tconst newAttributes = {};\n\t\tfor ( const name of Object.keys( geometry.attributes ) ) {\n\n\t\t\tconst oldAttribute = geometry.attributes[ name ];\n\t\t\tconst newArray = new oldAttribute.array.constructor( ( indexes.length + splitIndexes.length ) * oldAttribute.itemSize );\n\t\t\tnewArray.set( oldAttribute.array );\n\t\t\tnewAttributes[ name ] = new BufferAttribute( newArray, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t}\n\n\t\tvar newIndexes = new Uint32Array( indexes.length );\n\t\tnewIndexes.set( indexes );\n\n\t\tfor ( var i = 0; i < splitIndexes.length; i ++ ) {\n\n\t\t\tvar split = splitIndexes[ i ];\n\t\t\tvar index = indexes[ split.original ];\n\n\t\t\tfor ( const attribute of Object.values( newAttributes ) ) {\n\n\t\t\t\tfor ( let j = 0; j < attribute.itemSize; j ++ ) {\n\n\t\t\t\t\tattribute.array[ ( indexes.length + i ) * attribute.itemSize + j ] =\n\t\t\t\t\t\tattribute.array[ index * attribute.itemSize + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var j of split.indexes ) {\n\n\t\t\t\tnewIndexes[ j ] = indexes.length + i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( newIndexes, 1 ) );\n\n\t\tfor ( const name of Object.keys( newAttributes ) ) {\n\n\t\t\tgeometry.setAttribute( name, newAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( hadNormals ) {\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tif ( oldNormals !== null ) {\n\n\t\t\t\tconst changedNormals = new Array( oldNormals.length / 3 ).fill( false );\n\n\t\t\t\tfor ( const splitData of splitIndexes )\n\t\t\t\t\tchangedNormals[ splitData.original ] = true;\n\n\t\t\t\tfor ( let i = 0; i < changedNormals.length; i ++ ) {\n\n\t\t\t\t\tif ( changedNormals[ i ] === false ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ )\n\t\t\t\t\t\t\tgeometry.attributes.normal.array[ 3 * i + j ] = oldNormals[ 3 * i + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t};\n\n};\n\nexport { EdgeSplitModifier };\n"]},"metadata":{},"sourceType":"module"}